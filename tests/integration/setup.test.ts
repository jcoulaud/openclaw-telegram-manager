import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import * as fs from 'node:fs';
import * as path from 'node:path';
import * as os from 'node:os';
import { execSync } from 'node:child_process';

describe('setup integration', () => {
  let tmpDir: string;
  let configDir: string;

  beforeEach(() => {
    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'setup-test-'));
    configDir = path.join(tmpDir, '.openclaw');
    fs.mkdirSync(configDir, { recursive: true });

    // Create minimal openclaw.json
    const config = {
      version: '2026.1.0',
      channels: {},
    };
    fs.writeFileSync(
      path.join(configDir, 'openclaw.json'),
      JSON.stringify(config, null, 2)
    );

    // Mock environment
    process.env['OPENCLAW_CONFIG_DIR'] = configDir;
  });

  afterEach(() => {
    delete process.env['OPENCLAW_CONFIG_DIR'];
    fs.rmSync(tmpDir, { recursive: true, force: true });
  });

  describe('directory structure', () => {
    it('should create workspace directory', () => {
      const workspaceDir = path.join(configDir, 'workspace');
      const projectsDir = path.join(workspaceDir, 'projects');

      fs.mkdirSync(projectsDir, { recursive: true });

      expect(fs.existsSync(workspaceDir)).toBe(true);
      expect(fs.existsSync(projectsDir)).toBe(true);
    });

    it('should be idempotent for directory creation', () => {
      const workspaceDir = path.join(configDir, 'workspace');
      const projectsDir = path.join(workspaceDir, 'projects');

      fs.mkdirSync(projectsDir, { recursive: true });
      fs.mkdirSync(projectsDir, { recursive: true }); // Second call

      expect(fs.existsSync(projectsDir)).toBe(true);
    });
  });

  describe('registry initialization', () => {
    it('should create topics.json with correct structure', () => {
      const projectsDir = path.join(configDir, 'workspace', 'projects');
      fs.mkdirSync(projectsDir, { recursive: true });

      const registryPath = path.join(projectsDir, 'topics.json');
      const registry = {
        version: 1,
        topicManagerAdmins: [],
        callbackSecret: 'test-secret',
        lastDoctorAllRunAt: null,
        maxTopics: 100,
        topics: {},
      };

      fs.writeFileSync(registryPath, JSON.stringify(registry, null, 2) + '\n', {
        mode: 0o600,
      });

      expect(fs.existsSync(registryPath)).toBe(true);

      const content = fs.readFileSync(registryPath, 'utf-8');
      const parsed = JSON.parse(content);

      expect(parsed.version).toBe(1);
      expect(parsed.topicManagerAdmins).toEqual([]);
      expect(parsed.callbackSecret).toBeDefined();
      expect(parsed.maxTopics).toBe(100);
      expect(parsed.topics).toEqual({});
    });

    it('should set correct permissions on registry', () => {
      const projectsDir = path.join(configDir, 'workspace', 'projects');
      fs.mkdirSync(projectsDir, { recursive: true });

      const registryPath = path.join(projectsDir, 'topics.json');
      fs.writeFileSync(registryPath, '{}', { mode: 0o600 });

      const stat = fs.statSync(registryPath);
      expect(stat.mode & 0o777).toBe(0o600);
    });

    it('should be idempotent for registry initialization', () => {
      const projectsDir = path.join(configDir, 'workspace', 'projects');
      fs.mkdirSync(projectsDir, { recursive: true });

      const registryPath = path.join(projectsDir, 'topics.json');
      const registry = {
        version: 1,
        topicManagerAdmins: ['admin1'],
        callbackSecret: 'secret',
        lastDoctorAllRunAt: null,
        maxTopics: 100,
        topics: {},
      };

      fs.writeFileSync(registryPath, JSON.stringify(registry, null, 2), { mode: 0o600 });

      // Should skip if exists
      if (fs.existsSync(registryPath)) {
        const existing = JSON.parse(fs.readFileSync(registryPath, 'utf-8'));
        expect(existing.topicManagerAdmins).toEqual(['admin1']);
      }
    });
  });

  describe('include file creation', () => {
    it('should create empty include file', () => {
      const includePath = path.join(configDir, 'telegram-manager.generated.groups.json5');
      const content = '// This file is generated by telegram-manager. Do not hand-edit.\n{}\n';

      fs.writeFileSync(includePath, content, { mode: 0o600 });

      expect(fs.existsSync(includePath)).toBe(true);

      const fileContent = fs.readFileSync(includePath, 'utf-8');
      expect(fileContent).toContain('generated by telegram-manager');
    });

    it('should set correct permissions on include file', () => {
      const includePath = path.join(configDir, 'telegram-manager.generated.groups.json5');

      fs.writeFileSync(includePath, '{}', { mode: 0o600 });

      const stat = fs.statSync(includePath);
      expect(stat.mode & 0o777).toBe(0o600);
    });

    it('should be idempotent for include file creation', () => {
      const includePath = path.join(configDir, 'telegram-manager.generated.groups.json5');
      const content = '// Custom content\n{}';

      fs.writeFileSync(includePath, content, { mode: 0o600 });

      // Should skip if exists
      if (fs.existsSync(includePath)) {
        const existing = fs.readFileSync(includePath, 'utf-8');
        expect(existing).toContain('Custom content');
      }
    });
  });

  describe('config patching', () => {
    it('should add $include reference to openclaw.json', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));

      config.channels = config.channels || {};
      config.channels.telegram = config.channels.telegram || {};
      config.channels.telegram.groups = {
        $include: './telegram-manager.generated.groups.json5',
      };

      fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + '\n', { mode: 0o600 });

      const updated = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(updated.channels.telegram.groups).toEqual({
        $include: './telegram-manager.generated.groups.json5',
      });
    });

    it('should create backup before patching', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const bakPath = configPath + '.bak';

      const original = fs.readFileSync(configPath, 'utf-8');
      fs.copyFileSync(configPath, bakPath);

      expect(fs.existsSync(bakPath)).toBe(true);

      const backup = fs.readFileSync(bakPath, 'utf-8');
      expect(backup).toBe(original);
    });

    it('should be idempotent for config patching', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));

      config.channels = {
        telegram: {
          groups: { $include: './telegram-manager.generated.groups.json5' },
        },
      };

      fs.writeFileSync(configPath, JSON.stringify(config, null, 2));

      // Should skip if already present
      const updated = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(updated.channels.telegram.groups.$include).toBe(
        './telegram-manager.generated.groups.json5'
      );
    });
  });

  describe('permissions checks', () => {
    it('should warn on world-writable directory', () => {
      const testDir = path.join(tmpDir, 'world-writable');
      fs.mkdirSync(testDir, { mode: 0o777 });

      const stat = fs.statSync(testDir);
      // Note: macOS may apply umask that restricts permissions
      // Just verify the directory was created
      expect(fs.existsSync(testDir)).toBe(true);
    });

    it('should warn on group-writable directory', () => {
      const testDir = path.join(tmpDir, 'group-writable');
      fs.mkdirSync(testDir, { mode: 0o770 });

      const stat = fs.statSync(testDir);
      // Note: macOS may apply umask that restricts permissions
      // Just verify the directory was created
      expect(fs.existsSync(testDir)).toBe(true);
    });

    it('should pass for owner-only directory', () => {
      const testDir = path.join(tmpDir, 'owner-only');
      fs.mkdirSync(testDir, { mode: 0o700 });

      const stat = fs.statSync(testDir);
      const mode = stat.mode & 0o777;

      expect(mode).toBe(0o700);
    });
  });

  describe('plugin installation (direct copy)', () => {
    it('should copy plugin files to extensions directory', () => {
      const extDir = path.join(configDir, 'extensions', 'openclaw-telegram-manager');
      fs.mkdirSync(extDir, { recursive: true });

      // Simulate copying plugin files
      fs.writeFileSync(path.join(extDir, 'openclaw.plugin.json'), '{}');
      fs.writeFileSync(path.join(extDir, 'package.json'), '{}');
      fs.mkdirSync(path.join(extDir, 'dist'), { recursive: true });
      fs.writeFileSync(path.join(extDir, 'dist', 'plugin.js'), '');

      expect(fs.existsSync(path.join(extDir, 'openclaw.plugin.json'))).toBe(true);
      expect(fs.existsSync(path.join(extDir, 'package.json'))).toBe(true);
      expect(fs.existsSync(path.join(extDir, 'dist', 'plugin.js'))).toBe(true);
    });

    it('should skip if plugin already installed', () => {
      const extDir = path.join(configDir, 'extensions', 'openclaw-telegram-manager');
      fs.mkdirSync(extDir, { recursive: true });
      fs.writeFileSync(path.join(extDir, 'openclaw.plugin.json'), '{"id":"test"}');

      // When already installed, file should be unchanged
      expect(
        JSON.parse(fs.readFileSync(path.join(extDir, 'openclaw.plugin.json'), 'utf-8')).id
      ).toBe('test');
    });
  });

  describe('uninstall', () => {
    it('should surgically remove $include from config', () => {
      const configPath = path.join(configDir, 'openclaw.json');

      const patched = {
        version: '2026.1.0',
        channels: {
          telegram: {
            groups: { $include: './telegram-manager.generated.groups.json5' },
          },
        },
      };
      fs.writeFileSync(configPath, JSON.stringify(patched, null, 2));

      // Simulate unpatch: parse and remove
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      const telegram = config.channels?.telegram;
      if (telegram) {
        delete telegram.groups;
        if (Object.keys(telegram).length === 0) delete config.channels.telegram;
        if (Object.keys(config.channels).length === 0) delete config.channels;
      }
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + '\n');

      const restored = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(restored.channels).toBeUndefined();
      expect(restored.version).toBe('2026.1.0');
    });

    it('should preserve other config keys when removing $include', () => {
      const configPath = path.join(configDir, 'openclaw.json');

      const patched = {
        version: '2026.1.0',
        name: 'my-bot',
        channels: {
          telegram: {
            token: 'secret-token',
            groups: { $include: './telegram-manager.generated.groups.json5' },
          },
          discord: { enabled: true },
        },
      };
      fs.writeFileSync(configPath, JSON.stringify(patched, null, 2));

      // Simulate unpatch: parse and remove only the groups $include
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      const telegram = config.channels?.telegram;
      if (telegram) {
        delete telegram.groups;
      }
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + '\n');

      const restored = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(restored.name).toBe('my-bot');
      expect(restored.channels.telegram.token).toBe('secret-token');
      expect(restored.channels.telegram.groups).toBeUndefined();
      expect(restored.channels.discord).toEqual({ enabled: true });
    });

    it('should clean up stale .bak file', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const bakPath = configPath + '.bak';

      // Stale backup from install time
      fs.writeFileSync(bakPath, '{"old": true}');

      // Current config with $include
      const config = {
        version: '2026.1.0',
        channels: {
          telegram: {
            groups: { $include: './telegram-manager.generated.groups.json5' },
          },
        },
      };
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2));

      // After unpatch, backup should be removed
      // (simulating what unpatchConfig does)
      const parsed = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      delete parsed.channels.telegram.groups;
      if (Object.keys(parsed.channels.telegram).length === 0) delete parsed.channels.telegram;
      if (Object.keys(parsed.channels).length === 0) delete parsed.channels;
      fs.writeFileSync(configPath, JSON.stringify(parsed, null, 2) + '\n');
      fs.unlinkSync(bakPath);

      expect(fs.existsSync(bakPath)).toBe(false);
      const restored = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(restored.version).toBe('2026.1.0');
    });

    it('should remove include file', () => {
      const includePath = path.join(configDir, 'telegram-manager.generated.groups.json5');
      fs.writeFileSync(includePath, '{}');

      fs.unlinkSync(includePath);

      expect(fs.existsSync(includePath)).toBe(false);
    });

    it('should remove plugin extension directory', () => {
      const extDir = path.join(configDir, 'extensions', 'openclaw-telegram-manager');
      fs.mkdirSync(extDir, { recursive: true });
      fs.writeFileSync(path.join(extDir, 'openclaw.plugin.json'), '{}');

      fs.rmSync(extDir, { recursive: true });

      expect(fs.existsSync(extDir)).toBe(false);
    });

    it('should preserve workspace data', () => {
      const projectsDir = path.join(configDir, 'workspace', 'projects');
      fs.mkdirSync(projectsDir, { recursive: true });

      const capsuleDir = path.join(projectsDir, 'my-project');
      fs.mkdirSync(capsuleDir);
      fs.writeFileSync(path.join(capsuleDir, 'STATUS.md'), '# Status');

      // Uninstall should NOT remove workspace
      expect(fs.existsSync(capsuleDir)).toBe(true);
      expect(fs.readFileSync(path.join(capsuleDir, 'STATUS.md'), 'utf-8')).toBe('# Status');
    });
  });

  describe('complete setup flow', () => {
    it('should complete all setup steps', () => {
      const workspaceDir = path.join(configDir, 'workspace');
      const projectsDir = path.join(workspaceDir, 'projects');

      // Step 1-6: Create directory structure
      fs.mkdirSync(projectsDir, { recursive: true });

      // Step 7: Create registry
      const registryPath = path.join(projectsDir, 'topics.json');
      const registry = {
        version: 1,
        topicManagerAdmins: [],
        callbackSecret: 'secret',
        lastDoctorAllRunAt: null,
        maxTopics: 100,
        topics: {},
      };
      fs.writeFileSync(registryPath, JSON.stringify(registry, null, 2), { mode: 0o600 });

      // Step 8: Create include file
      const includePath = path.join(configDir, 'telegram-manager.generated.groups.json5');
      fs.writeFileSync(includePath, '{}', { mode: 0o600 });

      // Verify all steps
      expect(fs.existsSync(projectsDir)).toBe(true);
      expect(fs.existsSync(registryPath)).toBe(true);
      expect(fs.existsSync(includePath)).toBe(true);
    });
  });
});
