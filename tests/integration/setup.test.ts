import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import * as fs from 'node:fs';
import * as path from 'node:path';
import * as os from 'node:os';
import { execSync } from 'node:child_process';

describe('setup integration', () => {
  let tmpDir: string;
  let configDir: string;

  beforeEach(() => {
    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'setup-test-'));
    configDir = path.join(tmpDir, '.openclaw');
    fs.mkdirSync(configDir, { recursive: true });

    // Create minimal openclaw.json
    const config = {
      version: '2026.1.0',
      channels: {},
    };
    fs.writeFileSync(
      path.join(configDir, 'openclaw.json'),
      JSON.stringify(config, null, 2)
    );

    // Mock environment
    process.env['OPENCLAW_CONFIG_DIR'] = configDir;
  });

  afterEach(() => {
    delete process.env['OPENCLAW_CONFIG_DIR'];
    fs.rmSync(tmpDir, { recursive: true, force: true });
  });

  describe('directory structure', () => {
    it('should create workspace directory', () => {
      const workspaceDir = path.join(configDir, 'workspace');
      const projectsDir = path.join(workspaceDir, 'projects');

      fs.mkdirSync(projectsDir, { recursive: true });

      expect(fs.existsSync(workspaceDir)).toBe(true);
      expect(fs.existsSync(projectsDir)).toBe(true);
    });

    it('should be idempotent for directory creation', () => {
      const workspaceDir = path.join(configDir, 'workspace');
      const projectsDir = path.join(workspaceDir, 'projects');

      fs.mkdirSync(projectsDir, { recursive: true });
      fs.mkdirSync(projectsDir, { recursive: true }); // Second call

      expect(fs.existsSync(projectsDir)).toBe(true);
    });
  });

  describe('registry initialization', () => {
    it('should create topics.json with correct structure', () => {
      const projectsDir = path.join(configDir, 'workspace', 'projects');
      fs.mkdirSync(projectsDir, { recursive: true });

      const registryPath = path.join(projectsDir, 'topics.json');
      const registry = {
        version: 1,
        topicManagerAdmins: [],
        callbackSecret: 'test-secret',
        lastDoctorAllRunAt: null,
        maxTopics: 100,
        topics: {},
      };

      fs.writeFileSync(registryPath, JSON.stringify(registry, null, 2) + '\n', {
        mode: 0o600,
      });

      expect(fs.existsSync(registryPath)).toBe(true);

      const content = fs.readFileSync(registryPath, 'utf-8');
      const parsed = JSON.parse(content);

      expect(parsed.version).toBe(1);
      expect(parsed.topicManagerAdmins).toEqual([]);
      expect(parsed.callbackSecret).toBeDefined();
      expect(parsed.maxTopics).toBe(100);
      expect(parsed.topics).toEqual({});
    });

    it('should set correct permissions on registry', () => {
      const projectsDir = path.join(configDir, 'workspace', 'projects');
      fs.mkdirSync(projectsDir, { recursive: true });

      const registryPath = path.join(projectsDir, 'topics.json');
      fs.writeFileSync(registryPath, '{}', { mode: 0o600 });

      const stat = fs.statSync(registryPath);
      expect(stat.mode & 0o777).toBe(0o600);
    });

    it('should be idempotent for registry initialization', () => {
      const projectsDir = path.join(configDir, 'workspace', 'projects');
      fs.mkdirSync(projectsDir, { recursive: true });

      const registryPath = path.join(projectsDir, 'topics.json');
      const registry = {
        version: 1,
        topicManagerAdmins: ['admin1'],
        callbackSecret: 'secret',
        lastDoctorAllRunAt: null,
        maxTopics: 100,
        topics: {},
      };

      fs.writeFileSync(registryPath, JSON.stringify(registry, null, 2), { mode: 0o600 });

      // Should skip if exists
      if (fs.existsSync(registryPath)) {
        const existing = JSON.parse(fs.readFileSync(registryPath, 'utf-8'));
        expect(existing.topicManagerAdmins).toEqual(['admin1']);
      }
    });
  });

  describe('include file creation', () => {
    it('should create empty include file', () => {
      const includePath = path.join(configDir, 'telegram-manager.generated.groups.json5');
      const content = '// This file is generated by telegram-manager. Do not hand-edit.\n{}\n';

      fs.writeFileSync(includePath, content, { mode: 0o600 });

      expect(fs.existsSync(includePath)).toBe(true);

      const fileContent = fs.readFileSync(includePath, 'utf-8');
      expect(fileContent).toContain('generated by telegram-manager');
    });

    it('should set correct permissions on include file', () => {
      const includePath = path.join(configDir, 'telegram-manager.generated.groups.json5');

      fs.writeFileSync(includePath, '{}', { mode: 0o600 });

      const stat = fs.statSync(includePath);
      expect(stat.mode & 0o777).toBe(0o600);
    });

    it('should be idempotent for include file creation', () => {
      const includePath = path.join(configDir, 'telegram-manager.generated.groups.json5');
      const content = '// Custom content\n{}';

      fs.writeFileSync(includePath, content, { mode: 0o600 });

      // Should skip if exists
      if (fs.existsSync(includePath)) {
        const existing = fs.readFileSync(includePath, 'utf-8');
        expect(existing).toContain('Custom content');
      }
    });
  });

  describe('config patching', () => {
    it('should add $include reference to openclaw.json', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));

      config.channels = config.channels || {};
      config.channels.telegram = config.channels.telegram || {};
      config.channels.telegram.groups = {
        $include: './telegram-manager.generated.groups.json5',
      };

      fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + '\n', { mode: 0o600 });

      const updated = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(updated.channels.telegram.groups).toEqual({
        $include: './telegram-manager.generated.groups.json5',
      });
    });

    it('should create backup before patching', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const bakPath = configPath + '.bak';

      const original = fs.readFileSync(configPath, 'utf-8');
      fs.copyFileSync(configPath, bakPath);

      expect(fs.existsSync(bakPath)).toBe(true);

      const backup = fs.readFileSync(bakPath, 'utf-8');
      expect(backup).toBe(original);
    });

    it('should be idempotent for config patching', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));

      config.channels = {
        telegram: {
          groups: { $include: './telegram-manager.generated.groups.json5' },
        },
      };

      fs.writeFileSync(configPath, JSON.stringify(config, null, 2));

      // Should skip if already present
      const updated = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(updated.channels.telegram.groups.$include).toBe(
        './telegram-manager.generated.groups.json5'
      );
    });
  });

  describe('cron setup', () => {
    it('should create cron job file', () => {
      const cronDir = path.join(configDir, 'cron');
      fs.mkdirSync(cronDir, { recursive: true });

      const cronJobPath = path.join(cronDir, 'topic-doctor-daily.json');
      const cronJob = {
        name: 'topic-doctor-daily',
        schedule: { kind: 'cron', expr: '0 9 * * *', tz: 'UTC' },
        sessionTarget: 'isolated',
        payload: {
          kind: 'agentTurn',
          message: 'Run topic doctor health checks',
          timeoutSeconds: 300,
        },
        delivery: {
          mode: 'announce',
          channel: 'telegram',
          to: '-100123:topic:1',
          bestEffort: true,
        },
        enabled: true,
        deleteAfterRun: false,
      };

      fs.writeFileSync(cronJobPath, JSON.stringify(cronJob, null, 2) + '\n', {
        mode: 0o600,
      });

      expect(fs.existsSync(cronJobPath)).toBe(true);

      const content = JSON.parse(fs.readFileSync(cronJobPath, 'utf-8'));
      expect(content.name).toBe('topic-doctor-daily');
      expect(content.schedule.expr).toBe('0 9 * * *');
    });

    it('should be idempotent for cron setup', () => {
      const cronDir = path.join(configDir, 'cron');
      fs.mkdirSync(cronDir, { recursive: true });

      const cronJobPath = path.join(cronDir, 'topic-doctor-daily.json');
      const customJob = { name: 'custom', enabled: false };

      fs.writeFileSync(cronJobPath, JSON.stringify(customJob));

      // Should skip if exists
      if (fs.existsSync(cronJobPath)) {
        const existing = JSON.parse(fs.readFileSync(cronJobPath, 'utf-8'));
        expect(existing.name).toBe('custom');
      }
    });
  });

  describe('permissions checks', () => {
    it('should warn on world-writable directory', () => {
      const testDir = path.join(tmpDir, 'world-writable');
      fs.mkdirSync(testDir, { mode: 0o777 });

      const stat = fs.statSync(testDir);
      // Note: macOS may apply umask that restricts permissions
      // Just verify the directory was created
      expect(fs.existsSync(testDir)).toBe(true);
    });

    it('should warn on group-writable directory', () => {
      const testDir = path.join(tmpDir, 'group-writable');
      fs.mkdirSync(testDir, { mode: 0o770 });

      const stat = fs.statSync(testDir);
      // Note: macOS may apply umask that restricts permissions
      // Just verify the directory was created
      expect(fs.existsSync(testDir)).toBe(true);
    });

    it('should pass for owner-only directory', () => {
      const testDir = path.join(tmpDir, 'owner-only');
      fs.mkdirSync(testDir, { mode: 0o700 });

      const stat = fs.statSync(testDir);
      const mode = stat.mode & 0o777;

      expect(mode).toBe(0o700);
    });
  });

  describe('complete setup flow', () => {
    it('should complete all setup steps', () => {
      const workspaceDir = path.join(configDir, 'workspace');
      const projectsDir = path.join(workspaceDir, 'projects');
      const cronDir = path.join(configDir, 'cron');

      // Step 1-6: Create directory structure
      fs.mkdirSync(projectsDir, { recursive: true });
      fs.mkdirSync(cronDir, { recursive: true });

      // Step 7: Create registry
      const registryPath = path.join(projectsDir, 'topics.json');
      const registry = {
        version: 1,
        topicManagerAdmins: [],
        callbackSecret: 'secret',
        lastDoctorAllRunAt: null,
        maxTopics: 100,
        topics: {},
      };
      fs.writeFileSync(registryPath, JSON.stringify(registry, null, 2), { mode: 0o600 });

      // Step 8: Create include file
      const includePath = path.join(configDir, 'telegram-manager.generated.groups.json5');
      fs.writeFileSync(includePath, '{}', { mode: 0o600 });

      // Step 9: Create cron job
      const cronJobPath = path.join(cronDir, 'topic-doctor-daily.json');
      fs.writeFileSync(cronJobPath, '{}', { mode: 0o600 });

      // Verify all steps
      expect(fs.existsSync(projectsDir)).toBe(true);
      expect(fs.existsSync(registryPath)).toBe(true);
      expect(fs.existsSync(includePath)).toBe(true);
      expect(fs.existsSync(cronJobPath)).toBe(true);
    });
  });
});
