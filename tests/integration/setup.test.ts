import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import * as fs from 'node:fs';
import * as path from 'node:path';
import * as os from 'node:os';
import { execSync } from 'node:child_process';

describe('setup integration', () => {
  let tmpDir: string;
  let configDir: string;

  beforeEach(() => {
    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'setup-test-'));
    configDir = path.join(tmpDir, '.openclaw');
    fs.mkdirSync(configDir, { recursive: true });

    // Create minimal openclaw.json
    const config = {
      version: '2026.1.0',
      channels: {},
    };
    fs.writeFileSync(
      path.join(configDir, 'openclaw.json'),
      JSON.stringify(config, null, 2)
    );

    // Mock environment
    process.env['OPENCLAW_CONFIG_DIR'] = configDir;
  });

  afterEach(() => {
    delete process.env['OPENCLAW_CONFIG_DIR'];
    fs.rmSync(tmpDir, { recursive: true, force: true });
  });

  describe('directory structure', () => {
    it('should create workspace directory', () => {
      const workspaceDir = path.join(configDir, 'workspace');
      const projectsDir = path.join(workspaceDir, 'projects');

      fs.mkdirSync(projectsDir, { recursive: true });

      expect(fs.existsSync(workspaceDir)).toBe(true);
      expect(fs.existsSync(projectsDir)).toBe(true);
    });

    it('should be idempotent for directory creation', () => {
      const workspaceDir = path.join(configDir, 'workspace');
      const projectsDir = path.join(workspaceDir, 'projects');

      fs.mkdirSync(projectsDir, { recursive: true });
      fs.mkdirSync(projectsDir, { recursive: true }); // Second call

      expect(fs.existsSync(projectsDir)).toBe(true);
    });
  });

  describe('registry initialization', () => {
    it('should create topics.json with correct structure', () => {
      const projectsDir = path.join(configDir, 'workspace', 'projects');
      fs.mkdirSync(projectsDir, { recursive: true });

      const registryPath = path.join(projectsDir, 'topics.json');
      const registry = {
        version: 1,
        topicManagerAdmins: [],
        callbackSecret: 'test-secret',
        lastDoctorAllRunAt: null,
        maxTopics: 100,
        topics: {},
      };

      fs.writeFileSync(registryPath, JSON.stringify(registry, null, 2) + '\n', {
        mode: 0o600,
      });

      expect(fs.existsSync(registryPath)).toBe(true);

      const content = fs.readFileSync(registryPath, 'utf-8');
      const parsed = JSON.parse(content);

      expect(parsed.version).toBe(1);
      expect(parsed.topicManagerAdmins).toEqual([]);
      expect(parsed.callbackSecret).toBeDefined();
      expect(parsed.maxTopics).toBe(100);
      expect(parsed.topics).toEqual({});
    });

    it('should set correct permissions on registry', () => {
      const projectsDir = path.join(configDir, 'workspace', 'projects');
      fs.mkdirSync(projectsDir, { recursive: true });

      const registryPath = path.join(projectsDir, 'topics.json');
      fs.writeFileSync(registryPath, '{}', { mode: 0o600 });

      const stat = fs.statSync(registryPath);
      expect(stat.mode & 0o777).toBe(0o600);
    });

    it('should be idempotent for registry initialization', () => {
      const projectsDir = path.join(configDir, 'workspace', 'projects');
      fs.mkdirSync(projectsDir, { recursive: true });

      const registryPath = path.join(projectsDir, 'topics.json');
      const registry = {
        version: 1,
        topicManagerAdmins: ['admin1'],
        callbackSecret: 'secret',
        lastDoctorAllRunAt: null,
        maxTopics: 100,
        topics: {},
      };

      fs.writeFileSync(registryPath, JSON.stringify(registry, null, 2), { mode: 0o600 });

      // Should skip if exists
      if (fs.existsSync(registryPath)) {
        const existing = JSON.parse(fs.readFileSync(registryPath, 'utf-8'));
        expect(existing.topicManagerAdmins).toEqual(['admin1']);
      }
    });
  });

  describe('include file creation', () => {
    it('should create empty include file', () => {
      const includePath = path.join(configDir, 'telegram-manager.generated.groups.json5');
      const content = '// This file is generated by telegram-manager. Do not hand-edit.\n{}\n';

      fs.writeFileSync(includePath, content, { mode: 0o600 });

      expect(fs.existsSync(includePath)).toBe(true);

      const fileContent = fs.readFileSync(includePath, 'utf-8');
      expect(fileContent).toContain('generated by telegram-manager');
    });

    it('should set correct permissions on include file', () => {
      const includePath = path.join(configDir, 'telegram-manager.generated.groups.json5');

      fs.writeFileSync(includePath, '{}', { mode: 0o600 });

      const stat = fs.statSync(includePath);
      expect(stat.mode & 0o777).toBe(0o600);
    });

    it('should be idempotent for include file creation', () => {
      const includePath = path.join(configDir, 'telegram-manager.generated.groups.json5');
      const content = '// Custom content\n{}';

      fs.writeFileSync(includePath, content, { mode: 0o600 });

      // Should skip if exists
      if (fs.existsSync(includePath)) {
        const existing = fs.readFileSync(includePath, 'utf-8');
        expect(existing).toContain('Custom content');
      }
    });

    it('should preserve existing inline groups in generated include file', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const includePath = path.join(configDir, 'telegram-manager.generated.groups.json5');

      // Start with inline groups in config
      const config = {
        version: '2026.1.0',
        channels: {
          telegram: {
            groups: {
              '-1003731538650': { requireMention: false },
            },
          },
        },
      };
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2));

      // Simulate what patchConfig does: extract inline groups before overwriting
      const parsed = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      const telegram = parsed.channels.telegram;
      let existingGroups: Record<string, unknown> | null = null;
      const groups = telegram.groups;
      if (groups && typeof groups === 'object' && !('$include' in groups)) {
        existingGroups = groups;
      }

      // Overwrite with $include
      telegram.groups = { $include: './telegram-manager.generated.groups.json5' };
      fs.writeFileSync(configPath, JSON.stringify(parsed, null, 2) + '\n', { mode: 0o600 });

      // Simulate createEmptyInclude with seedGroups
      const body = existingGroups && Object.keys(existingGroups).length > 0
        ? JSON.stringify(existingGroups, null, 2)
        : '{}';
      const content = '// This file is generated by telegram-manager. Do not hand-edit.\n' + body + '\n';
      fs.writeFileSync(includePath, content, { mode: 0o600 });

      // Verify the include file contains the original inline groups
      const includeContent = fs.readFileSync(includePath, 'utf-8');
      const includeData = JSON.parse(
        includeContent.split('\n').filter(l => !l.startsWith('//')).join('\n')
      );
      expect(includeData['-1003731538650']).toBeDefined();
      expect(includeData['-1003731538650'].requireMention).toBe(false);

      // Verify the config now has $include
      const updatedConfig = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(updatedConfig.channels.telegram.groups.$include).toBe(
        './telegram-manager.generated.groups.json5'
      );
    });
  });

  describe('config patching', () => {
    it('should add $include reference to openclaw.json', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));

      config.channels = config.channels || {};
      config.channels.telegram = config.channels.telegram || {};
      config.channels.telegram.groups = {
        $include: './telegram-manager.generated.groups.json5',
      };

      fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + '\n', { mode: 0o600 });

      const updated = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(updated.channels.telegram.groups).toEqual({
        $include: './telegram-manager.generated.groups.json5',
      });
    });

    it('should create backup before patching', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const bakPath = configPath + '.bak';

      const original = fs.readFileSync(configPath, 'utf-8');
      fs.copyFileSync(configPath, bakPath);

      expect(fs.existsSync(bakPath)).toBe(true);

      const backup = fs.readFileSync(bakPath, 'utf-8');
      expect(backup).toBe(original);
    });

    it('should be idempotent for config patching', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));

      config.channels = {
        telegram: {
          groups: { $include: './telegram-manager.generated.groups.json5' },
        },
      };

      fs.writeFileSync(configPath, JSON.stringify(config, null, 2));

      // Should skip if already present
      const updated = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(updated.channels.telegram.groups.$include).toBe(
        './telegram-manager.generated.groups.json5'
      );
    });
  });

  describe('permissions checks', () => {
    it('should warn on world-writable directory', () => {
      const testDir = path.join(tmpDir, 'world-writable');
      fs.mkdirSync(testDir, { mode: 0o777 });

      const stat = fs.statSync(testDir);
      // Note: macOS may apply umask that restricts permissions
      // Just verify the directory was created
      expect(fs.existsSync(testDir)).toBe(true);
    });

    it('should warn on group-writable directory', () => {
      const testDir = path.join(tmpDir, 'group-writable');
      fs.mkdirSync(testDir, { mode: 0o770 });

      const stat = fs.statSync(testDir);
      // Note: macOS may apply umask that restricts permissions
      // Just verify the directory was created
      expect(fs.existsSync(testDir)).toBe(true);
    });

    it('should pass for owner-only directory', () => {
      const testDir = path.join(tmpDir, 'owner-only');
      fs.mkdirSync(testDir, { mode: 0o700 });

      const stat = fs.statSync(testDir);
      const mode = stat.mode & 0o777;

      expect(mode).toBe(0o700);
    });
  });

  describe('plugin installation (direct copy)', () => {
    it('should copy plugin files to extensions directory', () => {
      const extDir = path.join(configDir, 'extensions', 'openclaw-telegram-manager');
      fs.mkdirSync(extDir, { recursive: true });

      // Simulate copying plugin files
      fs.writeFileSync(path.join(extDir, 'openclaw.plugin.json'), '{}');
      fs.writeFileSync(path.join(extDir, 'package.json'), '{}');
      fs.mkdirSync(path.join(extDir, 'dist'), { recursive: true });
      fs.writeFileSync(path.join(extDir, 'dist', 'plugin.js'), '');

      expect(fs.existsSync(path.join(extDir, 'openclaw.plugin.json'))).toBe(true);
      expect(fs.existsSync(path.join(extDir, 'package.json'))).toBe(true);
      expect(fs.existsSync(path.join(extDir, 'dist', 'plugin.js'))).toBe(true);
    });

    it('should overwrite existing plugin files on reinstall', () => {
      const extDir = path.join(configDir, 'extensions', 'openclaw-telegram-manager');
      fs.mkdirSync(extDir, { recursive: true });
      fs.writeFileSync(path.join(extDir, 'openclaw.plugin.json'), '{"id":"old"}');

      // Simulate reinstall: overwrite with new content
      fs.writeFileSync(path.join(extDir, 'openclaw.plugin.json'), '{"id":"new"}');

      expect(
        JSON.parse(fs.readFileSync(path.join(extDir, 'openclaw.plugin.json'), 'utf-8')).id
      ).toBe('new');
    });
  });

  describe('uninstall', () => {
    it('should surgically remove $include from config', () => {
      const configPath = path.join(configDir, 'openclaw.json');

      const patched = {
        version: '2026.1.0',
        channels: {
          telegram: {
            groups: { $include: './telegram-manager.generated.groups.json5' },
          },
        },
      };
      fs.writeFileSync(configPath, JSON.stringify(patched, null, 2));

      // Simulate unpatch: parse and remove
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      const telegram = config.channels?.telegram;
      if (telegram) {
        delete telegram.groups;
        if (Object.keys(telegram).length === 0) delete config.channels.telegram;
        if (Object.keys(config.channels).length === 0) delete config.channels;
      }
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + '\n');

      const restored = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(restored.channels).toBeUndefined();
      expect(restored.version).toBe('2026.1.0');
    });

    it('should preserve other config keys when removing $include', () => {
      const configPath = path.join(configDir, 'openclaw.json');

      const patched = {
        version: '2026.1.0',
        name: 'my-bot',
        channels: {
          telegram: {
            token: 'secret-token',
            groups: { $include: './telegram-manager.generated.groups.json5' },
          },
          discord: { enabled: true },
        },
      };
      fs.writeFileSync(configPath, JSON.stringify(patched, null, 2));

      // Simulate unpatch: parse and remove only the groups $include
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      const telegram = config.channels?.telegram;
      if (telegram) {
        delete telegram.groups;
      }
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + '\n');

      const restored = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(restored.name).toBe('my-bot');
      expect(restored.channels.telegram.token).toBe('secret-token');
      expect(restored.channels.telegram.groups).toBeUndefined();
      expect(restored.channels.discord).toEqual({ enabled: true });
    });

    it('should clean up stale .bak file', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const bakPath = configPath + '.bak';

      // Stale backup from install time
      fs.writeFileSync(bakPath, '{"old": true}');

      // Current config with $include
      const config = {
        version: '2026.1.0',
        channels: {
          telegram: {
            groups: { $include: './telegram-manager.generated.groups.json5' },
          },
        },
      };
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2));

      // After unpatch, backup should be removed
      // (simulating what unpatchConfig does)
      const parsed = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      delete parsed.channels.telegram.groups;
      if (Object.keys(parsed.channels.telegram).length === 0) delete parsed.channels.telegram;
      if (Object.keys(parsed.channels).length === 0) delete parsed.channels;
      fs.writeFileSync(configPath, JSON.stringify(parsed, null, 2) + '\n');
      fs.unlinkSync(bakPath);

      expect(fs.existsSync(bakPath)).toBe(false);
      const restored = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(restored.version).toBe('2026.1.0');
    });

    it('should remove include file', () => {
      const includePath = path.join(configDir, 'telegram-manager.generated.groups.json5');
      fs.writeFileSync(includePath, '{}');

      fs.unlinkSync(includePath);

      expect(fs.existsSync(includePath)).toBe(false);
    });

    it('should remove plugin extension directory', () => {
      const extDir = path.join(configDir, 'extensions', 'openclaw-telegram-manager');
      fs.mkdirSync(extDir, { recursive: true });
      fs.writeFileSync(path.join(extDir, 'openclaw.plugin.json'), '{}');

      fs.rmSync(extDir, { recursive: true });

      expect(fs.existsSync(extDir)).toBe(false);
    });

    it('should restore inline groups from include file on uninstall', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const includePath = path.join(configDir, 'telegram-manager.generated.groups.json5');

      // Config with $include reference
      const patched = {
        version: '2026.1.0',
        channels: {
          telegram: {
            token: 'secret-token',
            groups: { $include: './telegram-manager.generated.groups.json5' },
          },
        },
      };
      fs.writeFileSync(configPath, JSON.stringify(patched, null, 2));

      // Include file with actual group settings
      const groups = {
        '-1003731538650': { requireMention: false },
        '-1009876543210': { requireMention: true },
      };
      fs.writeFileSync(
        includePath,
        '// This file is generated by telegram-manager. Do not hand-edit.\n' +
          JSON.stringify(groups, null, 2) + '\n',
      );

      // Simulate unpatchConfig: read include, restore inline, clean up
      const content = fs.readFileSync(configPath, 'utf-8');
      const config = JSON.parse(content);
      const telegram = config.channels?.telegram;
      if (telegram && fs.existsSync(includePath)) {
        const raw = fs.readFileSync(includePath, 'utf-8');
        const jsonBody = raw.replace(/^\s*\/\/.*$/gm, '').trim();
        const parsed = JSON.parse(jsonBody);
        if (parsed && typeof parsed === 'object' && Object.keys(parsed).length > 0) {
          telegram.groups = parsed;
        } else {
          delete telegram.groups;
        }
      }
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + '\n');
      fs.unlinkSync(includePath);

      const restored = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(restored.channels.telegram.token).toBe('secret-token');
      expect(restored.channels.telegram.groups).toEqual(groups);
      expect(fs.existsSync(includePath)).toBe(false);
    });

    it('should delete groups key when include file is empty', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const includePath = path.join(configDir, 'telegram-manager.generated.groups.json5');

      const patched = {
        version: '2026.1.0',
        channels: {
          telegram: {
            groups: { $include: './telegram-manager.generated.groups.json5' },
          },
        },
      };
      fs.writeFileSync(configPath, JSON.stringify(patched, null, 2));

      // Empty include file
      fs.writeFileSync(
        includePath,
        '// This file is generated by telegram-manager. Do not hand-edit.\n{}\n',
      );

      const content = fs.readFileSync(configPath, 'utf-8');
      const config = JSON.parse(content);
      const telegram = config.channels?.telegram;
      if (telegram && fs.existsSync(includePath)) {
        const raw = fs.readFileSync(includePath, 'utf-8');
        const jsonBody = raw.replace(/^\s*\/\/.*$/gm, '').trim();
        const parsed = JSON.parse(jsonBody);
        if (parsed && typeof parsed === 'object' && Object.keys(parsed).length > 0) {
          telegram.groups = parsed;
        } else {
          delete telegram.groups;
        }
        if (Object.keys(telegram).length === 0) delete config.channels.telegram;
        if (Object.keys(config.channels).length === 0) delete config.channels;
      }
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + '\n');

      const restored = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(restored.channels).toBeUndefined();
    });

    it('should preserve workspace data', () => {
      const projectsDir = path.join(configDir, 'workspace', 'projects');
      fs.mkdirSync(projectsDir, { recursive: true });

      const capsuleDir = path.join(projectsDir, 'my-project');
      fs.mkdirSync(capsuleDir);
      fs.writeFileSync(path.join(capsuleDir, 'STATUS.md'), '# Status');

      // Uninstall should NOT remove workspace
      expect(fs.existsSync(capsuleDir)).toBe(true);
      expect(fs.readFileSync(path.join(capsuleDir, 'STATUS.md'), 'utf-8')).toBe('# Status');
    });
  });

  describe('patchMemoryFlush', () => {
    const MEMORY_FLUSH_MARKER = 'topic capsule';
    const MEMORY_FLUSH_INSTRUCTION =
      'If you are working on a Telegram topic capsule (projects/<slug>/), update its STATUS.md with current "Last done (UTC)" and "Next actions (now)" before this context is compacted.';

    function patchMemoryFlush(cfgDir: string): void {
      const configPath = path.join(cfgDir, 'openclaw.json');
      if (!fs.existsSync(configPath)) return;

      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));

      if (!config.agents) config.agents = {};
      if (!config.agents.defaults) config.agents.defaults = {};
      if (!config.agents.defaults.compaction) config.agents.defaults.compaction = {};
      if (!config.agents.defaults.compaction.memoryFlush) config.agents.defaults.compaction.memoryFlush = {};

      const memoryFlush = config.agents.defaults.compaction.memoryFlush;
      const existing = typeof memoryFlush.prompt === 'string' ? memoryFlush.prompt : '';

      if (existing.includes(MEMORY_FLUSH_MARKER)) return;

      memoryFlush.prompt = existing
        ? existing + '\n' + MEMORY_FLUSH_INSTRUCTION
        : MEMORY_FLUSH_INSTRUCTION;

      fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + '\n', { mode: 0o600 });
    }

    it('should set prompt when missing', () => {
      patchMemoryFlush(configDir);

      const config = JSON.parse(fs.readFileSync(path.join(configDir, 'openclaw.json'), 'utf-8'));
      expect(config.agents.defaults.compaction.memoryFlush.prompt).toBe(MEMORY_FLUSH_INSTRUCTION);
    });

    it('should append to existing custom prompt', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      config.agents = {
        defaults: {
          compaction: {
            memoryFlush: { prompt: 'Save important context before compaction.' },
          },
        },
      };
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + '\n');

      patchMemoryFlush(configDir);

      const updated = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      const prompt = updated.agents.defaults.compaction.memoryFlush.prompt;
      expect(prompt).toContain('Save important context');
      expect(prompt).toContain(MEMORY_FLUSH_MARKER);
    });

    it('should be idempotent (does not duplicate)', () => {
      patchMemoryFlush(configDir);
      patchMemoryFlush(configDir);

      const config = JSON.parse(fs.readFileSync(path.join(configDir, 'openclaw.json'), 'utf-8'));
      const prompt = config.agents.defaults.compaction.memoryFlush.prompt as string;
      const occurrences = prompt.split(MEMORY_FLUSH_MARKER).length - 1;
      expect(occurrences).toBe(1);
    });
  });

  describe('unpatchMemoryFlush', () => {
    const MEMORY_FLUSH_MARKER = 'topic capsule';
    const MEMORY_FLUSH_INSTRUCTION =
      'If you are working on a Telegram topic capsule (projects/<slug>/), update its STATUS.md with current "Last done (UTC)" and "Next actions (now)" before this context is compacted.';

    function unpatchMemoryFlush(cfgDir: string): void {
      const configPath = path.join(cfgDir, 'openclaw.json');
      if (!fs.existsSync(configPath)) return;

      let content: string;
      try { content = fs.readFileSync(configPath, 'utf-8'); } catch { return; }
      if (!content.includes(MEMORY_FLUSH_MARKER)) return;

      let config: Record<string, unknown>;
      try { config = JSON.parse(content); } catch { return; }

      const agents = config['agents'] as Record<string, unknown> | undefined;
      const defaults = agents?.['defaults'] as Record<string, unknown> | undefined;
      const compaction = defaults?.['compaction'] as Record<string, unknown> | undefined;
      const memoryFlush = compaction?.['memoryFlush'] as Record<string, unknown> | undefined;
      if (!memoryFlush || typeof memoryFlush['prompt'] !== 'string') return;

      const prompt = memoryFlush['prompt'] as string;
      const cleaned = prompt.replace(MEMORY_FLUSH_INSTRUCTION, '').replace(/\n{2,}/g, '\n').trim();

      if (cleaned) {
        memoryFlush['prompt'] = cleaned;
      } else {
        delete memoryFlush['prompt'];
        if (Object.keys(memoryFlush).length === 0) delete compaction!['memoryFlush'];
        if (Object.keys(compaction!).length === 0) delete defaults!['compaction'];
        if (Object.keys(defaults!).length === 0) delete agents!['defaults'];
        if (Object.keys(agents!).length === 0) delete config['agents'];
      }

      fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + '\n', { mode: 0o600 });
    }

    it('should remove instruction and clean up empty agents tree', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const config = {
        version: '2026.1.0',
        channels: {},
        agents: {
          defaults: {
            compaction: {
              memoryFlush: { prompt: MEMORY_FLUSH_INSTRUCTION },
            },
          },
        },
      };
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + '\n');

      unpatchMemoryFlush(configDir);

      const restored = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(restored.agents).toBeUndefined();
      expect(restored.version).toBe('2026.1.0');
    });

    it('should preserve custom prompt when removing instruction', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const customPrompt = 'Save important context before compaction.';
      const config = {
        version: '2026.1.0',
        channels: {},
        agents: {
          defaults: {
            compaction: {
              memoryFlush: { prompt: customPrompt + '\n' + MEMORY_FLUSH_INSTRUCTION },
            },
          },
        },
      };
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + '\n');

      unpatchMemoryFlush(configDir);

      const restored = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(restored.agents.defaults.compaction.memoryFlush.prompt).toBe(customPrompt);
    });

    it('should be a no-op when marker is not present', () => {
      const configPath = path.join(configDir, 'openclaw.json');
      const config = {
        version: '2026.1.0',
        channels: {},
        agents: {
          defaults: {
            compaction: {
              memoryFlush: { prompt: 'Some other prompt.' },
            },
          },
        },
      };
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + '\n');

      unpatchMemoryFlush(configDir);

      const restored = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      expect(restored.agents.defaults.compaction.memoryFlush.prompt).toBe('Some other prompt.');
    });
  });

  describe('complete setup flow', () => {
    it('should complete all setup steps', () => {
      const workspaceDir = path.join(configDir, 'workspace');
      const projectsDir = path.join(workspaceDir, 'projects');

      // Step 1-6: Create directory structure
      fs.mkdirSync(projectsDir, { recursive: true });

      // Step 7: Create registry
      const registryPath = path.join(projectsDir, 'topics.json');
      const registry = {
        version: 1,
        topicManagerAdmins: [],
        callbackSecret: 'secret',
        lastDoctorAllRunAt: null,
        maxTopics: 100,
        topics: {},
      };
      fs.writeFileSync(registryPath, JSON.stringify(registry, null, 2), { mode: 0o600 });

      // Step 8: Create include file
      const includePath = path.join(configDir, 'telegram-manager.generated.groups.json5');
      fs.writeFileSync(includePath, '{}', { mode: 0o600 });

      // Verify all steps
      expect(fs.existsSync(projectsDir)).toBe(true);
      expect(fs.existsSync(registryPath)).toBe(true);
      expect(fs.existsSync(includePath)).toBe(true);
    });
  });
});
